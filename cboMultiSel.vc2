*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cbomultisel.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cbomultisel AS combobox 
	*<ClassComment>
		*A self-contained, single item class to provide a control for selecting
		*multiple values from a list and providing as a single, character-separated value..
		*
		*G. Willcockson - Mar 2020 - V1 Based on ideas of multiSelCombo pulled from the public domain.
	*</ClassComment>
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: controlsource_assign
		*m: crepicklistfrm
		*m: getsels		&& Build the final value and the display value from the selected datasource items.
		*m: list_gettoplvlfrm		&& Helper for the picklist form to get the top level form reference when dealing with positioning.
		*m: list_grddblclick		&& Picklist method to process a grid double-click (line item select/de-select request.
		*m: list_grdkeypress		&& Keypress handler for the picklist grid.
		*m: list_hide		&& Handler for piclist form events that require the form to be hidden.
		*m: list_init		&& Picklist form init handler.
		*m: list_selall		&& Picklist support method - select or clear all of the items based on the value of the current record selection status.
		*m: list_selclick		&& Click handler for the picklist grid - tests whether a  checkbox was clicked and set the value, accordingly.
		*m: list_setfrmposn		&& Picklist method to set the encapsulating form's screen position.
		*m: readonly_assign
		*m: rowsource_assign		&& (Re)builds the picklist grid on change of the Rowsource.
		*m: setsels		&& Sets the selected datasource items from the bound/control source.
		*p: autodrop		&& Flag whether to auto-dropdown on focus.
		*p: boundfld		&& The field or property to bind this control's value to.  If ControlSouce is provided, this will be used in its place.
		*p: dispvals		&& The display values of the selected items.
		*p: dropped		&& Flag to indicate whether list form is displayed.
		*p: list_readonly
		*p: selfrmref		&& Reference to the selection list form.
		*p: selitmbackcolor		&& Background color of selected picklist items.
		*p: selitmforecolor		&& Font color of selected items in the picklist.
		*p: showhdrs		&& Show headers switch.
		*p: srcalias		&& Dataource alias (table, cursor, etc.).
		*p: srccols		&& Comma-separated list of source data field names to display.
		*p: srccoltitls		&& Comma-separated list of list column titles.  Defaults are the column field names.
		*p: srcdispcol		&& Datasource column to use for accumulating dislpay values for the true selected values.  This can be a formula; for example a Transform to format each value.
		*p: srcvalcol		&& The datasource column for selected values.
		*p: valdelim		&& Deliminter to apply to selected values.  For example, quote characters.
		*p: valsepr		&& Selected values separator.  Also used as the separator for display values.
		*a: selrecnbrs[1,0]		&& Array of selected record numbers.
		*a: selvals[1,0]		&& Selected values array.
		*a: srccoldefs[1,4]		&& Datasource column information array (field name, width, title, format).  If undefined, this is populated from the source attributes.
	*</DefinedPropArrayMethod>

	HIDDEN list_readonly
	autodrop = .F.		&& Flag whether to auto-dropdown on focus.
	boundfld = 		&& The field or property to bind this control's value to.  If ControlSouce is provided, this will be used in its place.
	dispvals = 		&& The display values of the selected items.
	dropped = .F.		&& Flag to indicate whether list form is displayed.
	Height = 22
	list_readonly = .F.
	Name = "cbomultisel"
	selfrmref = .NULL.		&& Reference to the selection list form.
	selitmbackcolor = 10416627		&& Background color of selected picklist items.
	selitmforecolor = 0		&& Font color of selected items in the picklist.
	showhdrs = .T.		&& Show headers switch.
	srcalias = 		&& Dataource alias (table, cursor, etc.).
	srccols = 		&& Comma-separated list of source data field names to display.
	srccoltitls = 		&& Comma-separated list of list column titles.  Defaults are the column field names.
	srcdispcol = 		&& Datasource column to use for accumulating dislpay values for the true selected values.  This can be a formula; for example a Transform to format each value.
	srcvalcol = 		&& The datasource column for selected values.
	Style = 0
	valdelim = 		&& Deliminter to apply to selected values.  For example, quote characters.
	valsepr = ,		&& Selected values separator.  Also used as the separator for display values.
	Width = 179
	
	PROCEDURE controlsource_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		This.boundFld = vNewVal
		This.ControlSource = ""
	ENDPROC

	PROCEDURE crepicklistfrm
		This.selFrmRef = CREATEOBJECT("Form")
		
		WITH This.selFrmRef
			.Name = "cbomultiselfrm"
			.BorderStyle = 0
			.Caption = "cboMultiFrm"
			.Closable = .F.
			.KeyPreview = .T.
			.TitleBar = 0
			.AlwaysOnTop = .T.
		ENDWITH
		
		This.List_Init(This, Thisform)
		
	ENDPROC

	PROCEDURE Destroy
		IF VARTYPE(This.selFrmRef)="O" AND !ISNULL(This.selFrmRef)
			This.selFrmRef.Release()
			This.selFrmRef= .NULL.
		ENDIF
		
	ENDPROC

	PROCEDURE DropDown
		NODEFAULT 
		LOCAL iCnt, iSiz, i
		WITH This
			IF !EMPTY(.srcAlias)
				iCnt = RECCOUNT(.srcAlias)
				IF iCnt = 0
					RETURN
				ELSE
					iSiz = ALEN(This.selRecNbrs, 1)
					IF iSiz <> iCnt
						DIMENSION This.selRecNbrs[iCnt]
						for i = iSiz TO iCnt
							This.selRecNbrs[i] = .F.
						next
					endif 	
				endif  
				
				IF VARTYPE(.selFrmRef)<>"O" OR ISNULL(.selFrmRef)
					.crePickListFrm()
					BINDEVENT(Thisform, "QueryUnload", This, "Destroy", 1)
					BINDEVENT(Thisform, "Destroy", This, "Destroy", 1)
				ELSE
					* reset position in case this container form was moved
					.List_SetFrmPosn(Thisform)
				ENDIF
				
				DOEVENTS
				
				.selFrmRef.visible = .t.
				.dropped = .t.
				.selFrmRef.grdList.Refresh()
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE getsels		&& Build the final value and the display value from the selected datasource items.
		local liCnt, liSelCnt, lcVal, lcValType, lcSelVals, lnFrstPos
		
		liCnt = 0
		liSelCnt = 0
		lcSelVals = ''
		lnFrstPos = 0
		
		select (This.srcAlias)
		
		lcValType = Type(This.srcValCol)
		lcCmd = "CAST('' AS "+lcValType+")"
		This.selVals = &lcCmd
		This.dispVals = ''
		
		SCAN
			liCnt = liCnt + 1
			
			IF This.selRecNbrs[Recno()]
				
				liSelCnt = liSelCnt + 1
				
				IF lnFrstPos = 0
					lnFrstPos = RECNO()
				ENDIF
				
				IF !EMPTY(This.srcValCol)
				
					do case 
					case lcValType = 'C'
						lcVal = Strtran(Evaluate(This.srcValCol), This.valDelim, '')
					OTHERWISE && lcValType $ 'N,Y,D,T'
						lcVal = Transform(Evaluate(This.srcValCol))
					endcase 
					
					lcSelVals = lcSelVals;
						+ IIF(liSelCnt>1, This.valSepr, '');
						+ This.valDelim + ALLTRIM(lcVal) + This.valDelim
					
					DIMENSION This.selVals[liSelCnt]
					This.selVals[liSelCnt] = Evaluate(This.srcValCol)
					
				ENDIF
				
				IF !EMPTY(This.srcDispCol)
					This.dispVals = This.dispVals;
						+ Iif(liSelCnt > 1, This.valSepr,'');
						+ Trim(Transform(Evaluate(This.srcDispCol)))
				ENDIF
			ENDIF
		ENDSCAN
		
		IF lnFrstPos>0
			GO lnFrstPos
		ELSE
			GO TOP
		ENDIF
		
		* Don't know if the binding source is a field or property
		TRY
			REPLACE (This.boundFld) WITH lcSelVals
		CATCH
			STORE lcSelVals TO (This.boundFld)
		ENDTRY
		This.Refresh(.T.)
		
	ENDPROC

	PROCEDURE Init
		* Muliti-Select Combobox Control
		* G. Willcockson - Mar 2020
		
		* A class that defines a combo-style control for selecting multiple
		* values from a list and storing as a single, character-separated string.
		* This was inspired by, and is a total rebuild of, a similar control floating around:
		* "multiSelCombo".
		
		* See the accompanying test form, MultiSelTest.sc?, for examples. But for a quick overview,
		* - place this control on a form and configure its rowSource property:
		*		must be 2 (table/cursor alias), 3 (SQL statement), or 6 (fields)
		* - then, perhaps in the form init event, something like this:
		*
		*		*.RowSourceType=6	&& Fields
		*		.ControlSource="Thisform.mySels"	&& what we'll bind the value to
		*		.ColumnWidths = "15, 200"
		*		.srcValCol = "CD"			&& data source column/field to use for the values
		*		.srcDispCol = "NME"			&& data source column to use for the display values
		*		.valDelim = "'"				&& optional delimiter to surround selected values with
		*		.srcColTitls = "Code, Name" && titles for the columns (if headers are shown)
		*		.RowSource = "CSRC.CD, NME"	&& the data columns for the picklist (set this property last)
		
		#define MSG_CLASS_ERROR "Class Error"
		#define MSG_WRONG_ROWSOURCETYPE "This control only supports RowSourceTypes is 2,3 or 6"
		
		WITH THIS
			IF !INLIST(.RowSourceType, 2, 3, 6)
				MESSAGEBOX(MSG_WRONG_ROWSOURCETYPE ,64, MSG_CLASS_ERROR )
				RETURN .F.
			ENDIF
			
			.boundFld = .ControlSource
			.ControlSource = ""
			
			.Rowsource_Assign()
			
		ENDWITH
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		*Ctrl+Down , Alt+Down, F4
		DO CASE
		CASE nKeyCode = 145 OR nKeycode = -3 OR nKeyCode = 160
			IF this.dropped
				KEYBOARD '{ESC}' 
			ELSE 
				this.DropDown()
			ENDIF 
			RETURN
		CASE nShiftAltCtrl=0;
			AND !INLIST(nKeyCode,  1,  6,  9,  4,  5, 13, 19, 24, 27)
			NODEFAULT
			RETURN
		CASE nShiftAltCtrl=1;
			AND !INLIST(nKeyCode, 55, 49, 15, 54, 56, 13, 52, 50)
			NODEFAULT
			RETURN
		ENDCASE
		
		
	ENDPROC

	HIDDEN PROCEDURE list_gettoplvlfrm		&& Helper for the picklist form to get the top level form reference when dealing with positioning.
		*from Foundation Classes "_ui.vcx"
		
		ASSERT TYPE("_SCREEN.ActiveForm") # "O"  OR ;
		       INLIST(_SCREEN.ActiveForm.ShowWindow, 0,1,2)
		
		DO CASE
		CASE _SCREEN.FormCount = 0 OR ;
		     (TYPE("_SCREEN.ActiveForm") = "O" AND ;
		     _SCREEN.ActiveForm.ShowWindow = 0 )     && ShowWindow In Screen
				     
		     loTopForm = _SCREEN
		
		CASE (TYPE("_SCREEN.ActiveForm") = "O" AND ;
		      _SCREEN.ActiveForm.ShowWindow = 2 )    && ShowWindow As Top Form
		
		     loTopForm = _SCREEN.ActiveForm
				     
		OTHERWISE 
				                                       
		     FOR EACH loForm IN _SCREEN.Forms  && note: these may be toolbars
		                                       && if undocked, but that's okay --
		                                       && they are only ShowWIndow 0 or 1.
		
		        IF loForm.ShowWindow = 2 && the first one in the collection will
		                                && be "active top form"
		           loTopForm = loForm
		           EXIT
		        ENDIF
		     ENDFOR
				     
		     IF VARTYPE(loTopForm) # "O"
		        loTopForm = _SCREEN
		     ENDIF
				          
		ENDCASE
		
		RETURN loTopForm     
		
	ENDPROC

	HIDDEN PROCEDURE list_grddblclick		&& Picklist method to process a grid double-click (line item select/de-select request.
		IF !This.List_ReadOnly
			This.selRecNbrs(Recno()) = !This.selRecNbrs(Recno())
			This.selFrmRef.grdList.colSel.chkSel.Visible = .T.	&& force repaint
			This.selFrmRef.grdList.ActivateCell(This.selFrmRef.grdList.RelativeRow,1) 
		ENDIF
	ENDPROC

	HIDDEN PROCEDURE list_grdkeypress		&& Keypress handler for the picklist grid.
		LPARAMETERS nKeyCode, nShiftAltCtrl
		if nKeyCode = 32 and nShiftAltCtrl = 0
			This.List_GrdDblClick() 
		endif
		IF (nKeyCode = 13 and nShiftAltCtrl = 0);
			OR (nKeyCode = 9 AND nShiftAltCtrl = 0);
			OR (nKeyCode = 15 AND nShiftAltCtrl = 1);
			OR (nKeyCode = 27)
			This.selFrmRef.Hide()
		ENDIF
	ENDPROC

	HIDDEN PROCEDURE list_hide		&& Handler for piclist form events that require the form to be hidden.
		This.dropped = .f. 
		This.getSels()
		This.selFrmRef.hide()
	ENDPROC

	HIDDEN PROCEDURE list_init		&& Picklist form init handler.
		LPARAMETERS toCboMultiSelRef, toFrmRef
		
		LOCAL lnI, loTopLvlFrm
		
		IF ISNULL(toCboMultiSelRef) OR VARTYPE(toCboMultiSelRef) <> 'O'
			RETURN .f.
		ELSE
			* Reference to the combo control this supports
			This.selFrmRef.AddProperty("cboMultiSelRef", toCboMultiSelRef)
		ENDIF 
		
		WITH This.selFrmRef
		
			.AddObject("grdList", "Grid")
		
			WITH .grdList
				.AllowAutoColumnFit = 2
				.AllowCellSelection = .F.
				.AllowHeaderSizing = .F.
				.AllowRowSizing = .F.
				.Anchor = 0
				.DeleteMark = .F.
				.GridLineColor = RGB(190, 190, 190)
				.HeaderHeight = 18
				.HighlightRow = .T.
				.HighlightStyle = 2
				.Left = 0
				.Partition = 1
				.Panel = 1
				.ReadOnly = .F.
				.RecordMark = .F.
				.RecordSourceType = 1
				.RowHeight = 16
				.ScrollBars = 2
				.Top = 0
				.RecordSource = ""
				.Visible = .T.
		
				IF !This.showHdrs
					.HeaderHeight = 0
				ENDIF
				.Height = .HeaderHeight;
					+ .RowHeight * IIF(This.DisplayCount>0, .cboMultiSelRef.DisplayCount, 7)
		
				.RecordSource = This.srcAlias
				.ColumnCount = ALEN(This.srcColDefs,1) + 1
		
				FOR lnI=1 TO .ColumnCount
		
					WITH .Columns(lnI)
		
						IF lnI = 1
							* the selection (checkbox) column
		
							.Name = "colSel"
							.ControlSource="Thisform.cboMultiSelRef.selRecNbrs[RECNO()]"
							.Width = 28
							.ReadOnly = .F.
							.Header1.Caption = CHR(252)
							.Header1.Alignment = 2	&& middle center
							.RemoveObject("Text1")
							.AddObject("ChkSel", "Checkbox")
							.ChkSel.Caption = ""
							.ChkSel.Centered = .T.
							.ChkSel.Readonly = .F.
							.ChkSel.Visible = .T.
							.Sparse = .F.
							.Alignment = 2
		
							* initialize grid width to column 1 plus the scroll bar width
							.Parent.Width = .Width + SYSMETRIC(5)
		
						ELSE
		
							IF TYPE("This.srcColDefs[lnI-1,1]") = 'C'
		
								.ReadOnly = .T.
								.Width = This.srcColDefs[lnI-1,2]
								.Header1.Caption = This.srcColDefs[lnI-1,3]
								IF !EMPTY(This.srcColDefs[lnI-1,4])
									.ControlSource = "TRANSFORM("+This.srcAlias +'.'+This.srcColDefs[lnI-1,1];
										+",["+This.srcColDefs[lnI-1,4]+"])"
								ELSE
									.ControlSource = This.srcAlias +'.'+This.srcColDefs[lnI-1,1]
								ENDIF
								.Parent.Width = .Parent.Width + .Width + .Parent.GridLineWidth
							ENDIF
		
						ENDIF
		
					ENDWITH
		
				NEXT lnI
		
				.SetAll("FontName", This.FontName)
				.SetAll("FontSize", This.FontSize)
				.Columns(1).Header1.FontName = "Wingdings"	&& special check character
		
				.SetAll('DynamicBackColor' ;
					,"Iif(Thisform.cboMultiSelRef.selRecNbrs[Recno()], Thisform.cboMultiSelRef.SelItmBackColor, Thisform.grdList.BackColor)" ;
					,'Column') 
		
				.SetAll('DynamicForeColor' ;
					,"Iif(Thisform.cboMultiSelRef.selRecNbrs[Recno()], Thisform.cboMultiSelRef.SelItmForeColor, Thisform.grdList.ForeColor)" ;
					,'Column') 
		
			ENDWITH
		
			.Height = .grdList.Height + 2
			.Width = .grdList.Width + 6
			
		ENDWITH 
		
		BINDEVENT(This.selFrmRef, "Deactivate", This, "List_Hide")
		BINDEVENT(This.selFrmRef, "LostFocus", This, "List_Hide")
		BINDEVENT(This.selFrmRef.grdList.colSel.Header1, "CLICK", This, "List_SelAll", 1)
		BINDEVENT(This.selFrmRef.grdList, "DblClick", This, "List_GrdDblClick", 1)
		BINDEVENT(This.selFrmRef.grdList, "KeyPress", This, "List_GrdKeyPress", 1)
		BINDEVENT(This.selFrmRef.grdList, "MouseUp", This, "List_SelClick", 1)
		
		This.List_SetFrmPosn(toFrmRef)
		This.selFrmRef.grdList.Refresh()
		
	ENDPROC

	PROCEDURE list_selall		&& Picklist support method - select or clear all of the items based on the value of the current record selection status.
		LOCAL lnRec
		lnRec = RECNO(This.srcAlias)
		IF lnRec>0 AND NOT EOF(This.srcAlias) AND NOT BOF(This.srcAlias);
			AND !This.selRecNbrs[lnRec]
			This.selRecNbrs = .T.
		ELSE
			This.selRecNbrs = .F.
		ENDIF
		This.selFrmRef.grdList.Refresh()
		
	ENDPROC

	HIDDEN PROCEDURE list_selclick		&& Click handler for the picklist grid - tests whether a  checkbox was clicked and set the value, accordingly.
		LPARAMETERS tnButton, tnShift, tnX, tnY
		
		DODEFAULT()
		
		LOCAL lnWhere, lnRelRow, lnRelCol, lnView
		
		IF This.selFrmRef.grdList.GridHitTest(tnX, tnY, @lnWhere, @lnRelRow, @lnRelCol, @lnView)
			IF lnWhere=3 AND lnRelCol=1
				This.List_GrdDblClick()
			ENDIF
		ENDIF
		
	ENDPROC

	HIDDEN PROCEDURE list_setfrmposn		&& Picklist method to set the encapsulating form's screen position.
		*-- Sets the Top and Left of this form to match the reference combo position.
		LPARAMETERS toFrmRef
		
		WITH This.selFrmRef
			.Top = .cboMultiSelRef.Height + OBJTOCLIENT(.cboMultiSelRef,1)  ;
				+ SYSMETRIC(4) + SYSMETRIC(9) + toFrmRef.Top
			.Left = OBJTOCLIENT(.cboMultiSelRef,2) + SYSMETRIC(3) + toFrmRef.Left
		
			*check to see if "drop up" or horizontal position shifting needed
			loTopLvlFrm = This.List_GetTopLvlFrm() &&get host form reference for setting position
		
			DO CASE 
			CASE toFrmRef.ShowWindow = 0 OR toFrmRef.ShowWindow = 1
				IF .Left + .Width > loTopLvlFrm.Width 
					.Left = loTopLvlFrm.Width - .Width - 4
				ENDIF
		
				IF .Top + .Height  > loTopLvlFrm.Height
					.Top = .Top - .cboMultiSelRef.Height - .Height - 2
				ENDIF 
			CASE  toFrmRef.ShowWindow = 2
				IF .Left + .Width > SYSMETRIC(1)
					.Left = SYSMETRIC(1) - .Width - 4
				ENDIF
		
				IF .Top + .Height  > SYSMETRIC(2)
					.Top = .Top - .cboMultiSelRef.Height - .Height - 2
				ENDIF 
			ENDCASE
		ENDWITH
		
	ENDPROC

	PROCEDURE readonly_assign
		LPARAMETERS vNewVal
		This.List_ReadOnly = vNewVal
		THIS.ReadOnly = .F.
		
	ENDPROC

	PROCEDURE Refresh
		LPARAMETERS tlSkipSetSels
		DODEFAULT()
		This.Value = EVALUATE(This.boundFld)
		IF !tlSkipSetSels
			*This.SetSels(This.Value)
			This.SetSels(This.Value)
		ENDIF
		This.DisplayValue = This.dispVals
		
	ENDPROC

	PROCEDURE rowsource_assign		&& (Re)builds the picklist grid on change of the Rowsource.
		LPARAMETERS vNewVal
		
		WITH THIS
			
			IF PCOUNT()>0
				.RowSource = m.vNewVal
			ENDIF
			
			IF !EMPTY(.RowSource)
				
				DO CASE
				CASE .RowSourceType = 2
					.srcAlias = .RowSource
					
				CASE .RowSourceType = 3
					lcSqlCmd = .RowSource
					&lcSqlCmd
					.srcAlias = ALIAS()
					
				CASE .RowSourceType = 6
					ln = AT(".", .RowSource)
					.srcAlias = LEFT(.RowSource, ln - 1)
					.srcCols = SUBSTR(.RowSource, ln + 1)
					
				ENDCASE
				
				IF EMPTY(.srcValCol)
					.srcValCol = FIELD(1)
				ENDIF
				IF EMPTY(.srcDispCol)
					.srcDispCol = FIELD(1)
				ENDIF
				
				IF EMPTY(.srcColDefs[1,1])
					* no configured column definitions - build from other data
					
					lnColCnt = 0
					
					IF INLIST(.RowSourceType, 2, 3) AND EMPTY(.srcCols)
						
						.srcCols = ''
						ln = AFIELDS(la, .srcAlias)
						FOR li = 1 TO ln
							.srcCols = .srcCols;
								+ IIF(li=1, '', ',');
								+ la[li,1]
						NEXT
						
					ENDIF
					
					lnColCnt = ALINES(laSrcCols, .srcCols, 5, ',')
					lnWidCnt = ALINES(laWids, .ColumnWidths, 5, ',')
					lnTitlCnt = ALINES(laTitls, .srcColTitls, 5, ',')
					
					DIMENSION .srcColDefs[lnColCnt, 4]
					
					FOR li = 1 TO lnColCnt
						
						.srcColDefs[li,1] = laSrcCols[li]
						
						IF li <= lnWidCnt
							.srcColDefs[li,2] = VAL(laWids[li])
						ELSE
							IF TYPE(.srcAlias+"."+laSrcCols[li])="C"
								.srcColDefs[li,2] = 220 + (10.57318 - 214.5835)/(1 + (LEN(EVALUATE(.srcAlias+"."+laSrcCols[li]))/13.7497)^2.003402)
							ELSE
								.srcColDefs[li,2] = 100
							ENDIF
						ENDIF
		
						*y = 214.5835 + (10.57318 - 214.5835)/(1 + (x/13.7497)^2.003402)
						*FONTMETRIC(6, .FontName, .FontSize)*LEN(EVALUATE(.srcAlias+"."+laSrcCols[li]))
										
						.srcColDefs[li,3] = IIF(li <= lnTitlCnt, laTitls[li], laSrcCols[li])
					ENDFOR
					
				ENDIF
				
				.RowSource = ""
				.RowSourceType = 1
				.ColumnCount = 1
				.ColumnWidths = ''
				
				DIMENSION .selRecNbrs[RECCOUNT(.srcAlias)]
				
			ENDIF
			
		ENDWITH
	ENDPROC

	PROCEDURE setsels		&& Sets the selected datasource items from the bound/control source.
		LPARAMETERS tVal
		
		local li, liSelCnt, liMatchCnt, lVal, llMatch, lnArea, lnFrstPos
		
		This.selRecNbrs = .F.
		
		Dimension This.selVals[1]
		This.selVals = ''
		This.dispVals = ''
		
		lnFrstPos = 0
		
		If !EMPTY(This.srcValCol) AND !EMPTY(This.srcAlias)
			
			lnArea = SELECT()
			
			Select (This.srcAlias)
			
			lcValType = Type(This.srcValCol)
			liSelCnt = ALINES(laVals, STRTRAN(tVal, This.valSepr, CHR(13)))
			liMatchCnt = 0
			
			GO TOP
			SCAN WHILE liMatchCnt < liSelCnt
				
				FOR li=1 TO liSelCnt
					
					IF !EMPTY(This.valDelim)
						laVals[li] = ALLTRIM(laVals[li])
						IF LEFT(laVals[li],1)=This.valDelim
							laVals[li] = SUBSTR(laVals[li], 2, LEN(laVals[li])-2)
						ENDIF
					ENDIF
					
					lVal = ALLTRIM(laVals[li])
					IF lcValType = 'C'
						llMatch = ALLTRIM(EVALUATE(This.srcValCol))==lVal
					ELSE
						DO CASE
						CASE lcValType = 'N'
							lVal = VAL(lVal)
						CASE lcValType = 'D'
							lVal = CTOD(lVal)
						CASE lcValType = 'T'
							lVal = TTOD(lVal)
						CASE lcValType = 'L'
							lVal = CAST(lVal AS L)
						OTHERWISE
							lVal = .NULL.
						ENDCASE
						
						llMatch = EVALUATE(This.srcValCol)=lVal
						
					ENDIF
					
					IF llMatch
						liMatchCnt = liMatchCnt + 1
						
						IF lnFrstPos = 0
							lnFrstPos = RECNO()
						ENDIF
						
						This.selRecNbrs[RECNO()] = .T.
						
						Dimension This.selVals[liMatchCnt]
						This.selVals[liMatchCnt] = EVALUATE(This.srcValCol)
						
						IF !EMPTY(This.srcDispCol)
							This.dispVals = This.dispVals;
								+ Iif(liMatchCnt> 1, This.valSepr,'');
								+ Trim(Transform(Evaluate(This.srcDispCol)))
						ENDIF
						
						EXIT
					ENDIF
					
				ENDFOR
				
			ENDSCAN
			
			IF lnFrstPos>0
				GO lnFrstPos
			ELSE
				GO TOP
			ENDIF
			
			SELECT (lnArea)
		
		ENDIF
		
		
	ENDPROC

ENDDEFINE
